<!DOCTYPE html>
<html>
<head>
    <title>gRPC Chat</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 40px auto; padding: 20px; }
        .container { border: 1px solid #ccc; padding: 20px; border-radius: 8px; }
        input[type="text"] { padding: 8px; width: 70%; }
        button { padding: 8px 16px; background-color: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        .response { margin-top: 20px; padding: 10px; background-color: #f0f0f0; border-radius: 4px; }
        #audio-controls { margin-top: 20px; padding: 20px; border: 1px solid #eee; border-radius: 8px; text-align: center; }
        canvas { width: 100%; background-color: #222; margin-top: 10px; border-radius: 4px; display: block; }
        canvas { width: 100%; background-color: #222; margin-top: 10px; border-radius: 4px; display: block; }
        #waveform { height: 100px; }
        #freq-spectrum { height: 100px; }
        #spectrogram { height: 200px; }
        .active { background-color: #dc3545; }
        .active:hover { background-color: #c82333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>gRPC Chat Client</h1>
        
        <div id="audio-controls">
            <h3>Audio Stream</h3>
            <button id="audio-toggle">Start Streaming</button>
            <button id="audio-toggle">Start Streaming</button>
            <canvas id="waveform"></canvas>
            <canvas id="freq-spectrum"></canvas>
            <canvas id="spectrogram"></canvas>
        </div>

        <form action="/send" method="post" style="margin-top: 20px;">
            <input type="text" name="name" placeholder="Enter your name" required>
            <button type="submit">Send</button>
        </form>
        {% if response %}
        <div class="response">
            <strong>Server Response:</strong> {{ response }}
        </div>
        {% endif %}
    </div>
</body>
    </div>
    </div>
    <script>
        const audioToggleBtn = document.getElementById('audio-toggle');
        const waveCanvas = document.getElementById('waveform');
        const freqCanvas = document.getElementById('freq-spectrum');
        const specCanvas = document.getElementById('spectrogram');
        
        const waveCtx = waveCanvas.getContext('2d');
        const freqCtx = freqCanvas.getContext('2d');
        const specCtx = specCanvas.getContext('2d', { willReadFrequently: true });
        
        let audioContext;
        let analyser;
        let microphone;
        let animationId;
        let isStreaming = false;

        let dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            dpr = window.devicePixelRatio || 1;
            
            // Helper to set canvas size correctly for High DPI
            function setSize(canvas) {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            }

            setSize(waveCanvas);
            setSize(freqCanvas);
            setSize(specCanvas);
        }
        function getFreqData(freq, sampleRate, dataArray) {
            // Revert to Linear Interpolation (Real Data representation)
            const nyquist = sampleRate / 2;
            const index = freq * (dataArray.length) / nyquist;
            const i1 = Math.floor(index);
            const i2 = i1 + 1;
            
            if (i1 >= dataArray.length) return 0;
            
            const v1 = dataArray[i1];
            const v2 = (i2 < dataArray.length) ? dataArray[i2] : v1;
            
            const t = index - i1;
            return v1 * (1 - t) + v2 * t;
        }

        function getColor(value) {
            const p = value / 255;
            if (p < 0.1) return `rgb(0,0,${Math.floor(p*10*255)})`;
            if (p < 0.3) return `rgb(0,${Math.floor((p-0.1)*5*255)},255)`;
            if (p < 0.6) return `rgb(0,255,${Math.floor((0.6-p)*3.33*255)})`;
            return `rgb(255,${Math.floor((1-p)*2.5*255)},0)`;
        }

        function drawVisualizer() {
            if (!isStreaming) return;

            animationId = requestAnimationFrame(drawVisualizer);

            const bufferLength = analyser.frequencyBinCount;
            // ByteFrequencyData for Spectrum and Spectrogram
            const freqData = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(freqData);
            
            // TimeDomainData for Waveform
            const timeData = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(timeData);

            // --- Draw Waveform (Oscilloscope) ---
            waveCtx.fillStyle = '#222';
            waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
            waveCtx.lineWidth = 2 * dpr;
            waveCtx.strokeStyle = '#00ff00'; // Green
            waveCtx.beginPath();
            
            const sliceWidth = waveCanvas.width * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = timeData[i] / 128.0;
                const y = v * waveCanvas.height / 2;
                if (i === 0) waveCtx.moveTo(x, y);
                else waveCtx.lineTo(x, y);
                x += sliceWidth;
            }
            waveCtx.lineTo(waveCanvas.width, waveCanvas.height/2);
            waveCtx.stroke();

            // --- Draw Frequency Spectrum (Bar Graph) ---
            freqCtx.fillStyle = '#222';
            freqCtx.fillRect(0, 0, freqCanvas.width, freqCanvas.height);

            // --- Draw Frequency Spectrum (Bar Graph - Log Bands) ---
            freqCtx.fillStyle = '#222';
            freqCtx.fillRect(0, 0, freqCanvas.width, freqCanvas.height);

            const minFreq = 20;
            const maxFreq = 20000;
            const sampleRate = audioContext.sampleRate;
            const logMin = Math.log10(minFreq);
            const logMax = Math.log10(maxFreq);
            const logRange = logMax - logMin;

            // Draw uniform bars
            // We'll calculate the value for each pixel column
            for (let x = 0; x < freqCanvas.width; x++) {
                // Determine the frequency represented by this x position
                // x / width = (log(f) - log(min)) / (log(max) - log(min))
                // log(f) = log(min) + (x/width) * logRange
                const logFreq = logMin + (x / freqCanvas.width) * logRange;
                const freq = Math.pow(10, logFreq);
                
                // Get interpolated value
                const value = getFreqData(freq, sampleRate, freqData);

                const barHeight = (value / 255) * freqCanvas.height;
                
                // Color based on x position (frequency)
                freqCtx.fillStyle = `hsl(${x / freqCanvas.width * 300}, 100%, 50%)`;
                
                // Draw 1px wide bar
                freqCtx.fillRect(x, freqCanvas.height - barHeight, 1, barHeight);
            }

            // Draw Frequency Labels
            freqCtx.fillStyle = '#fff';
            // Scale font size by dpr
            const fontSize = 12 * dpr;
            freqCtx.font = `bold ${fontSize}px sans-serif`;
            freqCtx.textAlign = 'left';
            freqCtx.fillText('20Hz', 4 * dpr, freqCanvas.height - 4 * dpr);
            freqCtx.textAlign = 'center';
            const x1k = (Math.log10(1000) - logMin) / logRange * freqCanvas.width;
            freqCtx.fillText('1kHz', x1k, freqCanvas.height - 4 * dpr);
            freqCtx.textAlign = 'right';
            freqCtx.fillText('20kHz', freqCanvas.width - 4 * dpr, freqCanvas.height - 4 * dpr);

            // --- Draw Spectrogram (Waterfall) ---
            // Draw previous image stretched to new size (shifted down by 1 pixel equivalent)
            // Note: Since we are drawing pixel-by-pixel, we can just use drawImage with correct coords
            specCtx.drawImage(specCanvas, 
                0, 0, specCanvas.width, specCanvas.height - 1 * dpr,
                0, 1 * dpr, specCanvas.width, specCanvas.height - 1 * dpr
            );
            
            // Draw new row with interpolation
             for (let x = 0; x < specCanvas.width; x++) {
                const logFreq = logMin + (x / specCanvas.width) * logRange;
                const freq = Math.pow(10, logFreq);
                const value = getFreqData(freq, sampleRate, freqData);
                
                specCtx.fillStyle = getColor(value);
                // Draw height of dpr to match 1 CSS pixel vertical movement
                specCtx.fillRect(x, 0, 1, 1 * dpr);
            }
        }

        async function startStream() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: true,
                        autoGainControl: false
                    } 
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                
                microphone.connect(analyser);
                analyser.fftSize = 16384; // Max resolution for best bass accuracy
                analyser.frequencyBinCount = 16384;
                analyser.smoothingTimeConstant = 0; // No time smoothing, exact tracking

                isStreaming = true;
                audioToggleBtn.textContent = 'Stop Streaming';
                audioToggleBtn.classList.add('active');
                
                drawVisualizer();

                audioToggleBtn.stream = stream;

            } catch (err) {
                console.error('Error accessing microphone:', err);
                alert('Error accessing microphone. Please ensure you have granted permission.');
            }
        }

        function stopStream() {
            if (audioToggleBtn.stream) {
                audioToggleBtn.stream.getTracks().forEach(track => track.stop());
                audioToggleBtn.stream = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            isStreaming = false;
            audioToggleBtn.textContent = 'Start Streaming';
            audioToggleBtn.classList.remove('active');
        }

        audioToggleBtn.addEventListener('click', () => {
            if (!isStreaming) {
                startStream();
            } else {
                stopStream();
            }
        });
    </script>
</body>
</html>
